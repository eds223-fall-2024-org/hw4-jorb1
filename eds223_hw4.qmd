---
title: "Prioritizing Potential Aquaculture Zones in Coastal California"
subtitle: "EDS 223 Homework #4"
author: "Bailey Jørgensen"
execute:
  warning: false
  message: false
format:
  html:
    code-fold: true
    toc: true
editor_options: 
  chunk_output_type: console
---

## Background

Marine aquaculture has the potential to play an important role in the global food supply as a more sustainable protein option than land-based meat production. Gentry et al. mapped the potential for marine aquaculture globally based on multiple constraints, including ship traffic, dissolved oxygen, and bottom depth. They found that global seafood demand could be met using less than 0.015% of the global ocean area.

For this analysis, I will determine which Exclusive Economic Zones (EEZ) on the West Coast of the United States are best suited to developing marine aquaculture for several species of oysters and (CHOOSE AN ANIMAL JORB). Suitable locations will be determined based on a range of suitable sea surface temperatures (SST) and depth values for the species. 

Data on species depth and temperature requirements came from SeaLifeBase. 

Data on sea surface temperatures came from NOAA's 5km Daily Global Satellite Sea Surface Temperature Anomaly v3.1.

Bathymetry data came from the General Bathymetric Chart of the Oceans (GEBCO). 

Data on Exclusive Economic Zones came from Marineregions.org. 
```{r, output = FALSE}
#| eval: true
#| echo: false

# Load libraries
library(tidyverse)
library(sf)
library(terra)
library(tmap)
library(tmaptools)
library(here)
library(testthat)
library(patchwork)
library(ggplot2)
library(tidyterra)
library(patchwork)
```

```{r, output = FALSE}
#| eval: true
#| echo: false
# Read in data

# Create a list of all images that have the extension.tif and contain the word sst
sst_list <- list.files("data",
                       pattern = glob2rx("*sst*.tif$"),
                       full.names = TRUE)

# Create a stack of the sst rasters
sst_stack <- rast(sst_list)

# Read in bathymetry raster data
bathymetry <- rast(here::here("data", "depth.tif"))

# Read in maritime boundaries vector file
maritime_boundaries <- read_sf(here::here("data", "wc_regions_clean.shp"))

```

```{r}
# Put any functions I create here?
```

```{r}
# Transform the CRS of the files to match
bathymetry <- terra::project(bathymetry, crs(sst_stack))

maritime_boundaries <- maritime_boundaries %>% 
  st_transform(crs = st_crs(bathymetry))

# Confirm that the CRS transformed as expected
test_that("The CRS of all data sets match", {
  expect_true(crs(sst_stack) == crs(bathymetry) && crs(bathymetry) == crs(maritime_boundaries))
})
```
## Data Processing

In order to perform this analysis, the data must be processed. Specifically, I must ensure that the Sea Surface Temperature data and Depth data can be combined, since the data have different resolutions, extents, and positions.


```{r}
# Find the mean SST from 2008-2012 (eg create single raster of average SST...)
sst_average <- mean(sst_stack)

# Convert average SST from Kelvin to Celsius by subtracting 273.15
sst_average_celsius <- sst_average - 273.15

```

After some initial processing of the SST raster stack, I want to take a quick look at the the bathymetry and SST data, to see what further processing might need to be done.


```{r, fig.width=10, fig.height=6}

# Plot bathymetry raster
plot_bathymetry <- ggplot() +
  geom_spatraster(data = bathymetry) +
  scale_fill_viridis_c(name = "Depth") +
  ggtitle("Bathymetry") +
  theme_minimal()

# Plot SST raster
plot_sst <- ggplot() +
  geom_spatraster(data = sst_average_celsius) +
  scale_fill_viridis_c(name = "Temperature (°C)") +
  ggtitle("Average SST (°C)") +
  theme_minimal()

# Combine the plots
plot_bathymetry + plot_sst

```
I suspect that the resolutions of these raster objects do not match, so I run a quick check to see:

```{r, echo=TRUE, results='markdown'}
cat("Resolution of SST Average (°C):", res(sst_average_celsius)[1], "x", res(sst_average_celsius)[2], "\n")
cat("Resolution of Bathymetry:", res(bathymetry)[1], "x", res(bathymetry)[2], "\n")
```
This check confirms my suspicions, and I decide to resample the bathymetry data to match the resolution of the SST data, using the nearest neighbor approach. Once the resolutions and CRS of the data matches, I can crop the bathymetry raster to match the extent of the SST raster. 

```{r, echo=TRUE, results='asis'}
# Resample the bathymetry data to match the resolution of the SST data using the nearest neighbor approach
bathymetry_resampled <- resample(bathymetry, sst_stack, method = "near")

# Verify the results
cat("Matched Resolution of SST Average (°C):", res(sst_average_celsius)[1], "x", res(sst_average_celsius)[2], "\n")
cat("Matched Resolution of Bathymetry:", res(bathymetry)[1], "x", res(bathymetry_resampled)[2], "\n")
    
# Crop the bathymetry raster at last
bathymetry_cropped <- crop(bathymetry_resampled, sst_average_celsius)

```

Now, to verify that my processing thus far has been successful, I will run a series of tests. One way to know that the rasters match, is if they are able to be successfully stacked together. This code will test for stackability, and then I will finally stack the two together. 

```{r}
#| echo: true
#| output: asis

# Check if the rasters have the same resolution
res_match <- all(res(bathymetry_cropped) == res(sst_average_celsius))

# Check if the rasters have the same extent
extent_match <- ext(bathymetry_cropped) == ext(sst_average_celsius)

# Check if the rasters have the same CRS
crs_match <- crs(bathymetry_cropped) == crs(sst_average_celsius)

# Print the results
cat("Resolution match:", res_match,"\n")
cat("Extent match:", extent_match,"\n")
cat("CRS match:", crs_match,"\n")

# Check if the rasters can be stacked
if (res_match && extent_match && crs_match) {
  print("The rasters can be stacked. Aw yeah!")
} else {
  print("The rasters cannot be stacked. Check your work!!!")
}

# Finally, lets do it! Stack that raster!
bathy_sst <- c(bathymetry_cropped, sst_average_celsius)
```

## Oysters: A "Pearl-fect" Match


After the data is properly prepared and processed, I can begin the analysis to find suitable locations for marine aquaculture. This means finding locations that are suitable in terms of both SST and depth. 

I will begin my analysis with oysters. Research has shown that oyster need the following conditions for optimal growth: 

- sea surface temperature: 11-30°C
- depth: 0-70 meters below sea level

With this in mind, I will first reclassify the SST data to only include raster values that are between 11 and 30 degrees Celsius. Using a similar process, I will reclassify the depth data to only include values that are above 70 meters below sea level. Let's see what that looks like:


```{r, fig.width=10, fig.height=6}

# Turn unneeded values to NA
optimal_sst <- sst_average_celsius
optimal_sst[optimal_sst < 11 | optimal_sst > 30] <- NA

# Do it again for the bathymetry data
optimal_bath <- bathymetry_cropped
optimal_bath[optimal_bath < -70 | optimal_bath > 0] <- NA

# Plot optimal bathymetry raster
plot_optimal_bath <- ggplot() +
  geom_spatraster(data = optimal_bath) +
  scale_fill_viridis_c(name = "Depth (m)") +
  ggtitle("Optimal Depth (m) for Oysters") +
  theme_minimal()

# Plot optimal SST raster
plot_optimal_sst <- ggplot() +
  geom_spatraster(data = optimal_sst) +
  scale_fill_viridis_c(name = "Temperature (°C)") +
  ggtitle("Optimal SST (°C) for Oysters") +
  theme_minimal()

# Combine the plots
plot_optimal_bath + plot_optimal_sst

```
To find suitable locations for oyster marine aquaculture, we’ll need to find locations that are suitable in terms of both SST and depth. Let's do it with code!

```{r, fig.width=10, fig.height=6}
# Use map algebra to find areas of overlap
overlap <- !is.na(optimal_sst) & !is.na(optimal_bath)

big_optimal <- optimal_sst * overlap + optimal_bath * overlap
plot(big_optimal, main = "Area Optimal for Oyster Growth")

```
The result we get is a map showing a relatively thin line representing the areas of the West Coast of the United States that have the most optimal conditions for oyster aquaculture. 

### Determine the most suitable EEZ (Exclusive Economic Zone) best suited for developing marine aquaculture for Oysters. 

Now, its time to bring in our EEZ data, to determine which EEZs best overlap with our zones of optimal conditions for oysters.  

First, lets take a look at the maritime boundaries data that we have.
```{r}
plot(maritime_boundaries)
```


```{r, fig.width=10, fig.height=6}
tm_shape(maritime_boundaries) +
  tm_polygons(col = "rgn",
              palette = "RdYlBu",
              title = "Region Name") +
  tm_layout(main.title = "West Coast EEZs",
            main.title.position = "center",
            legend.position = c(0.55, 0.60))
```
I need to select suitable cells within West Coast EEZs
```{r, fig.width=10, fig.height=6}
# Raterize the vector data
maritime_raster <- rasterize(maritime_boundaries, big_optimal)

# Find overlap: cells with non-NA values in both rasters
maritime_overlap <- !is.na(maritime_raster) & !is.na(big_optimal)

# Mask big_optimal to retain only overlapping cells
eez_mask <- mask(big_optimal, maritime_overlap)

# Convert overlap raster to polygons for tmap magic
overlap_vector <- as.polygons(eez_mask) %>% 
  st_as_sf()

# Map both vector and raster data
tm_shape(maritime_boundaries) +
  tm_polygons(col = "rgn",
              palette = "RdYlBu",
              #alpha = .5,
              title = "Region Name") +  
  tm_shape(overlap_vector) +
    tm_polygons(1) +
    tm_layout(main.title = "EEZs with Optimal\nOyster Habitat",
              main.title.position = "center",
              legend.outside = TRUE)

```

```{r}
# Convert raster to a data frame for plotting
big_optimal_df <- as.data.frame(big_optimal, xy = TRUE, na.rm = TRUE)

# Convert the eez_mask vector to an sf object
overlap_sf <- st_as_sf(as.polygons(eez_mask))

# Step 3: Plot with ggplot2
# ggplot() +
#   geom_sf(data = maritime_boundaries, fill = "lightblue", col = "black", alpha = 0.5) +
#   geom_raster(data = big_optimal_df, aes(x = x, y = y), interpolate = TRUE) +
#   scale_fill_viridis_c(option = "D") +  # Customize color scale as needed
#   geom_sf(data = overlap_sf, fill = "black", alpha = 0.5) +
#   theme_bw() +
#   ggtitle("EEZs with Optimal\nOyster Habitat") +
#   theme(legend.position = "bottom")
ggplot(data = big_optimal_df, aes(x = x, y = y)) +
  geom_point(shape = 16) +
  labs(x = "Longitude",
       y = "Latitude",
       title = "Optimal Oytsers") +
  theme_bw()
```
```{r}
tm_shape(maritime_boundaries) +
  tm_polygons(col = "rgn",
              palette = "RdYlBu",
              #alpha = .5,
              title = "Region Name") + 
  tm_shape(big_optimal_df) +
  tm_dots()
```


```{r}
# Find the area of the grid cells we find
```

```{r}
# Find the total suitable area within each EEZ (hint: it might be helful to rasterize the EEZ data)
```





